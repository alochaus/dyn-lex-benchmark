var bottomUpTree
set bottomUpTree = func (d) {
    var depth = d
    if depth > 0 {
        set depth = depth - 1
        @[
            left=bottomUpTree(depth),
            right=bottomUpTree(depth)
        ]
    } else {
        @[
            left=nil, 
            right=nil
        ]
    }
}

var itemCheck
set itemCheck = func (tree) {
    if tree == nil {
        1
    }
    else {
        1 + itemCheck(tree[:left]) + itemCheck(tree[:right])
    }
}

var stress
set stress = func (mindepth, maxdepth, depth) {
    val iterations = (2**((maxdepth - depth) + mindepth))
    
    var check = 1
    var i = 1
    loop {
        break if (i > iterations)
        
        val t = bottomUpTree(depth)
        set check = check + itemCheck(t)

        set i = i + 1
    }
    
    @[
        (:iterations, iterations),
        (:check, check)
    ]
}

var main
set main = func (n) {
    val N = n

    val mindepth = 4
    var maxdepth

    if (mindepth + 2) < N {
        set maxdepth = N
    } else {
        set maxdepth = mindepth + 2
    }


    println("N: ", N, "mindepth: ", mindepth, "maxdepth: ", maxdepth)
    
    val stretchdepth = maxdepth + 1
    val stretchtree = bottomUpTree(stretchdepth)
    println("stretch tree of depth", stretchdepth, "check: ", itemCheck(stretchtree))
    

    val longlivedtree = bottomUpTree(maxdepth)

    ;;println(longlivedtree)

    var depth = mindepth

    loop {
        break if (depth > maxdepth) 

        val r = stress(mindepth, maxdepth, depth)
        val iterations = r[:iterations]
        val check = r[:check]

        println(iterations, "trees of depth ", depth, "check: ", check)
        
        set depth = depth + 2
    }

    println("long lived tree of depth", maxdepth, "check: ", itemCheck(longlivedtree))
}

main(11)